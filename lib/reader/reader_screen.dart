import 'package:flutter/material.dart';

import '../common/entities.dart';
import '../common/extensions.dart';
import '../common/vitaminav_preferences.dart';

/// A screen that displays multiple dyanmically-built pages for a generic
/// scrollable content and allows to persistently change the font size
class ReaderScreen extends StatefulWidget {
  final String title;
  final List<Identifier> dbIds;
  final ReaderPageBuilder pageBuilder;
  final int initialPage;
  final double initialScroll;
  static final double fontSizeDefault = 14;
  static final double fontSizeMinimum = 10;
  static final double fontSizeMaximum = 18;
  final void Function(int index, double offset) scrollOrIndexChanged;

  /// Creates a screen that displays multiple scrollable pages, dynamically
  /// loading contents from the database.
  ///
  /// Each identifier in `dbIds` will generate a page, with content dynamically
  /// generated by a given `pageBuilder` function. `initialPage` indicates the
  /// index of the first page to be displayed. An `initialScroll` offset can
  /// also be given.
  ///
  /// The `scrollOrIndexChanged` callback will be triggered any time the user
  /// changes page or scrolls, taking as arguments the new index an scroll
  /// offset. This parameter can be used to save the current reading state.
  ReaderScreen({
    Key key,
    @required this.title,
    @required this.dbIds,
    @required this.pageBuilder,
    @required this.initialPage,
    this.initialScroll,
    this.scrollOrIndexChanged = defaultScrollOrIndexChanged,
  }) : super(key: key);

  static void defaultScrollOrIndexChanged(int index, double scroll) {}

  @override
  _ReaderScreen createState() => _ReaderScreen();
}

class _ReaderScreen extends State<ReaderScreen> {
  PageController _pageController;
  int _currentPage;
  final List<ChangeNotifier> disposable = [];

  @override
  void initState() {
    super.initState();
    _pageController = PageController(initialPage: widget.initialPage);
    _pageController.addListener(() {
      if (_currentPage == null ||
          (_pageController.page - _currentPage).abs() >= 1) {
        print('Changed page.');
        _currentPage = _pageController.page.round();
        widget.scrollOrIndexChanged(_pageController.page.round(), 0);
      }
    });

    disposable.add(_pageController);
  }

  void _changeFontSize(delta) {
    VitaminaVPreferences.of(context).fontSize =
        (VitaminaVPreferences.of(context).fontSize + delta).sat(
      upper: ReaderScreen.fontSizeMaximum,
      lower: ReaderScreen.fontSizeMinimum,
    );
  }

  void _scrollNext() {
    _pageController.nextPage(
        duration: Duration(milliseconds: 300), curve: Curves.easeInOut);
  }

  void _scrollPrev() {
    _pageController.previousPage(
        duration: Duration(milliseconds: 300), curve: Curves.easeInOut);
  }

  @override
  Widget build(BuildContext context) {
    final fontSize = VitaminaVPreferences.of(context).fontSize;
    print(VitaminaVPreferences.of(context).defaultPrefs);
    final appBarActions = [
      IconButton(
        icon: Icon(Icons.remove),
        onPressed: fontSize != null && fontSize > ReaderScreen.fontSizeMinimum
            ? () => _changeFontSize(-1)
            : null,
      ),
      Opacity(
        child: Icon(
          Icons.format_size,
        ),
        opacity: 0.5,
      ),
      IconButton(
        icon: Icon(Icons.add),
        onPressed: fontSize != null && fontSize < ReaderScreen.fontSizeMaximum
            ? () => _changeFontSize(1)
            : null,
      ),
    ];
    return Scaffold(
      appBar: AppBar(
        title: Text(widget.title),
        actions: appBarActions,
      ),
      body: PageView.builder(
          controller: _pageController,
          itemCount: widget.dbIds.length,
          itemBuilder: (context, index) {
            final scrollController = ScrollController(
              initialScrollOffset:
                  widget.initialPage == index && widget.initialScroll != null
                      ? widget.initialScroll
                      : 0.0,
              keepScrollOffset: true,
            );

            disposable.add(scrollController);

            if (widget.scrollOrIndexChanged != null) {
              scrollController.addListener(() {
                final scrollMargin = 50;
                final atTheBeginning =
                    (_pageController.page == 0 && scrollController.offset < 10);
                final atTheEnd =
                    _pageController.page == widget.dbIds.length - 1 &&
                        scrollController.offset >
                            scrollController.position.maxScrollExtent -
                                scrollMargin;

                if (atTheBeginning || atTheEnd) {
                  widget.scrollOrIndexChanged(null, null);
                } else {
                  widget.scrollOrIndexChanged(
                      _pageController.page.round(), scrollController.offset);
                }
              });
            }
            return DefaultTextStyle(
              style: TextStyle(
                fontFamily: 'RobotoSlab',
                fontSize: fontSize,
                color: Theme.of(context).brightness == Brightness.light
                    ? Colors.black
                    : Colors.white,
              ),
              child: widget.pageBuilder(
                dbIds: widget.dbIds,
                index: index,
                scrollPrev: (index ?? 0) > 0 ? _scrollPrev : null,
                scrollNext:
                    (index ?? 0) < widget.dbIds.length - 1 ? _scrollNext : null,
                scrollController: scrollController,
              ),
            );
          }),
    );
  }

  @override
  void dispose() {
    disposable.forEach((element) {
      element.dispose();
    });
    super.dispose();
  }
}

typedef ReaderPageBuilder = Widget Function({
  @required List<Identifier> dbIds,
  @required int index,
  ScrollController scrollController,
  void Function() scrollNext,
  void Function() scrollPrev,
});
